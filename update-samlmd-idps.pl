#!/usr/bin/env perl
# @author Guy Halse http://orcid.org/0000-0002-9388-8592
# @copyright Copyright (c) 2017, SAFIRE - South African Identity Federation
# @license https://github.com/safire-ac-za/monitoring-plugins/blob/master/LICENSE MIT License
#
use strict;
use warnings;
use 5.10.0;
use experimental 'smartmatch';
use Getopt::Long;
use Pod::Usage;
use LWP::UserAgent;
use XML::XPath;
use XML::XPath::XMLParser;
use Config::YAML;
use MIME::Base64::URLSafe;
use Crypt::CBC;
use Crypt::OpenSSL::X509;
use Date::Parse;

sub emailToken($$)
{
    my ($email, $key) = @_;
    my $cipher = Crypt::CBC->new(-key => $key, -cipher => 'DES');
    my $ciphertext = $cipher->encrypt($email);
    return MIME::Base64::URLSafe::encode($ciphertext);
}

# Read a config file
my $baseConfig = exists($ENV{'OMD_ROOT'}) ? $ENV{'OMD_ROOT'} . '/etc/samlmd-idps.cfg' : '/etc/samlmd-idps.cfg';
$baseConfig = 'samlmd-idps.cfg' unless -f $baseConfig;
$baseConfig = "/dev/null" unless -f $baseConfig;    # allow an empty config file

my $c = Config::YAML->new(
    config => $baseConfig,
    nagiosConfigDir => (exists($ENV{'OMD_ROOT'}) ? $ENV{'OMD_ROOT'} . '/etc/nagios/conf.d' : '/etc/nagios/conf.d'),
    nagiosConfigFile => 'samlmd-generated-idps.cfg',
    nagiosCheckCommand => '',
    nagiosRestartCommand => '',
    metadataURL => '',
    disableContacts => [],
    tokenKey => 'changeme',
);
GetOptions($c,
    'config|c=s',
    'verbose|v!',
    'force|f!',
    'restart|reload|r!',
    'nagiosConfigDir|C=s',
    'nagiosConfigFile|F=s',
    'metadataURL|U=s',
    'birkURL|B=s',
    'birkURN=s',
    'tokenKey|key|k=s',
    'write|w=s',
    'dump|D!',
    'help|h|?',
) or pod2usage(2);
pod2usage(-exitval=>1, -verbose=>2) if defined $c->{'help'};
$c->read($c->{'config'}) if defined $c->{'config'};

# allow the config file to be saved
if (defined $c->{'write'}) {
    $c->set('_outfile', $c->{'write'});
    printf STDERR "Writing config to '%s'\n", $c->{'write'};
    delete($c->{'write'});
    $c->write;
    exit;
}
# allow config to be dumped for debugging
if (defined $c->{'dump'}) {
    use Data::Dumper;
    print Dumper($c);
    exit;
}

# First, some sanity checks
die('nagiosConfigDir does not exist') unless -d $c->{'nagiosConfigDir'};
die('nagiosConfigFile is not writable') unless -w $c->{'nagiosConfigDir'} . '/' . $c->{'nagiosConfigFile'} or (!-e $c->{'nagiosConfigDir'} . '/' . $c->{'nagiosConfigFile'} and -w $c->{'nagiosConfigDir'});
die('metadataURL is mandatory') unless defined $c->{'metadataURL'} and $c->{'metadataURL'};

# Get a last modified timestamp
my $idpsConfLastModified = 0;
$idpsConfLastModified = (stat $c->{'nagiosConfigDir'} . '/' . $c->{'nagiosConfigFile'})[9] if (-e $c->{'nagiosConfigDir'} . '/' . $c->{'nagiosConfigFile'});

# Get the metadata
my $ua = LWP::UserAgent->new(
    'timeout' => 10,
    'env_proxy' => 1,
    'cookie_jar' => {},
);
my $response = $ua->get($c->{'metadataURL'});
die("Unable to get metadata file") unless $response->is_success and $response->header('Content-Type') eq 'application/xml';
printf(STDERR "Successfully fetched metadata from %s\n", $c->{'metadataURL'}) if defined $c->{'verbose'};

# check freshness
if ($response->last_modified() < $idpsConfLastModified) {
    printf(STDERR "Nothing to do (Last-Modified %d < %d)%s\n", $response->last_modified(), $idpsConfLastModified, defined $c->{'force'} ? ' [FORCED]' : '') if defined $c->{'verbose'};
    exit if (!defined $c->{'force'});
}

# Parse the metadata as XML
my $xp = XML::XPath->new('xml' => $response->decoded_content);
die("Unable to parse metadata as XML") unless defined $xp and $xp;

$xp->set_namespace('md', 'urn:oasis:names:tc:SAML:2.0:metadata');
$xp->set_namespace('shibmd', 'urn:mace:shibboleth:metadata:1.0');
die("XML does not contain <md:EntitiesDescriptor> as root") unless $xp->find('/md:EntitiesDescriptor');

# Find the entities
my $entities = $xp->find('/md:EntitiesDescriptor/md:EntityDescriptor');
die("Metadata does not seem to contain any entities") unless $entities->isa('XML::XPath::NodeSet');
printf(STDERR "Metadata contains %d entities\n", $entities->size) if defined $c->{'verbose'};

# write a file header
open(my $nagConf, '>', $c->{nagiosConfigDir} . '/' . $c->{nagiosConfigFile})
    or die('error opening $c->{nagiosConfigFile} for writing');
printf $nagConf "# Autogenerated: %s\n", scalar localtime();
print $nagConf "# Changes to this file will be overwritten - do not edit\n\n";

my %seenContacts = ();
my %seenScopes = ();

# Iterate through the entities
foreach my $entity ($entities->get_nodelist) {
    my $entityID = $entity->getAttribute('entityID');
    unless ($xp->find('md:IDPSSODescriptor', $entity)) {
        printf(STDERR "Skipping %s, not an <md:IDPSSODescriptor>\n", $entityID);
        next;
    }
    printf("ENTITY %s\n", $entityID) if defined $c->{'verbose'};

    # SAFIRE/WAYF proxies
    my $birkifiedEntityID = $entityID;
    if (defined $c->{'birkURL'}) {
        my $birkURL = $c->{'birkURL'};
        $birkURL =~ s/^(https?:\/\/)//;
        $birkifiedEntityID =~ s{^(https?:\/\/)(.*)$}{$1${birkURL}/$2}gi;
        $birkifiedEntityID = defined $c->{'birkURN'} . ':' . $entityID if defined $c->{'birkURN'} and $birkifiedEntityID eq $entityID;
    }

    # record details of the metadata certs
    my @certs;
    foreach my $cert ($xp->find('md:IDPSSODescriptor/md:KeyDescriptor/ds:KeyInfo/ds:X509Data/ds:X509Certificate', $entity)->get_nodelist) {
        my $x509 = Crypt::OpenSSL::X509->new_from_string("-----BEGIN CERTIFICATE-----\n".$cert->string_value."\n-----END CERTIFICATE-----\n", Crypt::OpenSSL::X509::FORMAT_PEM);
        my $subject = $x509->subject_name->get_entry_by_type('CN')->value(); $subject =~ s/[^\w .-]/_/g;
        push @certs, sprintf("%d/%s", str2time($x509->notAfter), $subject);
    }

    my $primaryScope = $xp->find('md:IDPSSODescriptor/md:Extensions/shibmd:Scope', $entity)->shift()->string_value;
    my $displayScope = $primaryScope;
    if (exists($seenScopes{$primaryScope}) and $seenScopes{$primaryScope}) {
        my $id = $entity->getAttribute('ID');
        $id =~ m/(\d+)$/;
        printf("SCOPE %s was duplicated, entity ID is %s, adding suffix %d\n", $primaryScope, $id, $1) if defined $c->{'verbose'} and defined $1;
        $primaryScope = sprintf('%s-%d', $primaryScope, $1) if defined $1;
    }
    $seenScopes{$primaryScope}++;
    printf("SCOPE %s\n", $primaryScope) if defined $c->{'verbose'};

    # merge any additional contacts from the config file into our XML node list
    if (defined $c->{'additionalContacts'}) {
        foreach my $addC (grep { $_->{'entityID'} eq $entityID } @{$c->{'additionalContacts'}}) {
            printf(STDERR "ADDITIONAL CONTACT %s for %s\n", $addC->{'mail'}, $entityID) if defined $c->{'verbose'};
            my $contactNode = XML::XPath::Node::Element->new('md:ContactPerson', $entity->getPrefix());
            $contactNode->appendAttribute(XML::XPath::Node::Attribute->new('contactType', 'monitoring', $entity->getPrefix()));
            if ($addC->{'mail'}) {
                my $mailNode = XML::XPath::Node::Element->new('md:EmailAddress', $entity->getPrefix());
                $mailNode->appendChild(XML::XPath::Node::Text->new($addC->{'mail'}));
                $contactNode->appendChild($mailNode);
            }
            if ($addC->{'givenName'}) {
                my $givenNameNode = XML::XPath::Node::Element->new('md:GivenName', $entity->getPrefix());
                $givenNameNode->appendChild(XML::XPath::Node::Text->new($addC->{'givenName'}));
                $contactNode->appendChild($givenNameNode);
            }
            if ($addC->{'sn'}) {
                my $snNode = XML::XPath::Node::Element->new('md:SurName', $entity->getPrefix());
                $snNode->appendChild(XML::XPath::Node::Text->new($addC->{'sn'}));
                $contactNode->appendChild($snNode);
            }
            $entity->appendChild($contactNode);
        }
    }

    my $contacts = $xp->find('md:ContactPerson[@contactType = "technical" or @contactType = "support" or @contactType = "monitoring"]', $entity);
    foreach my $contact ($contacts->get_nodelist) {
        my $givenName = $xp->findvalue('md:GivenName', $contact);
        my $sn = $xp->findvalue('md:SurName', $contact);
        my $mail = $xp->findvalue('md:EmailAddress', $contact);
        $mail =~ s/^mailto://;
        # Sanity check the contact
        if ($mail !~ m/^([^@]+)\@[a-z0-9\.]+$/i) {
            printf(STDERR "Skipping contact %s in entity %s\n", $mail, $entityID) if defined $c->{'verbose'};
            next;
        }
        my($defangedLocalPart) = lc($1); $defangedLocalPart =~ s/\W+/_/g;
        next if $seenContacts{sprintf("%s-%s", $primaryScope, $defangedLocalPart)}++;

        printf(STDERR "CONTACT %s\n", $mail) if defined $c->{'verbose'};
        printf $nagConf "# CONTACT %s (entityID=%s%s)\n", $mail, $entityID, ($xp->findvalue('@contactType', $contact) eq 'monitoring' ? ' source='.$c->{'nagiosConfigFile'} : '');
        print  $nagConf "# AUTOGENERATED - DO NOT EDIT!\n";
        print  $nagConf "define contact {\n";
        printf $nagConf "  contact_name                   samlmd-c-%s-%s\n", $primaryScope, $defangedLocalPart;
        printf $nagConf "  alias                          %s %s\n", $givenName, $sn if defined $givenName or defined $sn;
        printf $nagConf "  email                          %s\n", $mail;
        # Disable contacts that were excluded
        if ($mail ~~ $c->{disableContacts}) { # smartmatch
            print  $nagConf "  host_notifications_enabled     0\n";
            print  $nagConf "  host_notification_options      n\n";
            print  $nagConf "  service_notifications_enabled  0\n";
            print  $nagConf "  service_notification_options   n\n";
        }
        printf $nagConf "  _UNSUBSCRIBE_TOKEN             %s\n", emailToken($mail, $c->{'tokenKey'});
        printf $nagConf "  contactgroups                  samlmd-cg-%s\n", $primaryScope;
        print  $nagConf "  use                            samlmd-generated-contact\n";
        print  $nagConf "}\n\n";
    }

    # Create this as a contact group even if there is only one contact to ease the rest of the configuration
    printf $nagConf "# CONTACTGROUP %s\n", $primaryScope;
    print  $nagConf "# AUTOGENERATED - DO NOT EDIT!\n";
    print  $nagConf "define contactgroup {\n";
    printf $nagConf "  contactgroup_name              samlmd-cg-%s\n", $primaryScope;
    printf $nagConf "  alias                          IdP: %s\n", $primaryScope;
    print  $nagConf "}\n\n";

    printf $nagConf "# IDP %s (entityID=%s)\n", $primaryScope, $entityID;
    print  $nagConf "# AUTOGENERATED - DO NOT EDIT!\n";
    print  $nagConf "define service {\n";
    printf $nagConf "  service_description            idp-%s\n", $primaryScope;
    printf $nagConf "  display_name                   IdP: %s\n", $displayScope;
    printf $nagConf "  contact_groups                 samlmd-cg-%s\n", $primaryScope;
    print  $nagConf "  use                            samlmd-generated-idp\n";
    printf $nagConf "  _ENTITYID                      %s\n", $entityID;
    printf $nagConf "  _BIRKIFIEDENTITYID             %s\n", $birkifiedEntityID if defined $c->{'birkURL'};
    printf $nagConf "  _PRIMARYSCOPE                  %s\n", $displayScope;
    printf $nagConf "  _INSTITUTION                   %s\n", $xp->findvalue("md:Organization/md:OrganizationName[\@xml:lang='en']", $entity);
    printf $nagConf "  _CERTINFO                      %s\n", join('|', @certs) if @certs;
    print  $nagConf "}\n\n";

    # Service dependencies stop us sending notification when radsecproxy itself is broken
    printf $nagConf "# SERVICEDEPENDENCY %s\n", $primaryScope;
    print  $nagConf "# AUTOGENERATED - DO NOT EDIT!\n";
    print  $nagConf "define servicedependency {\n";
    printf $nagConf "  dependent_service_description  idp-%s\n", $primaryScope;
    print  $nagConf "  use                            samlmd-generated-servicedependency\n";
    print  $nagConf "}\n\n";

    # Service escalations allow us to notify the SOC if nobody resolves the problem
    printf $nagConf "# SERVICEESCALATION %s\n", $primaryScope;
    print  $nagConf "# AUTOGENERATED - DO NOT EDIT!\n";
    print  $nagConf "define serviceescalation {\n";
    printf $nagConf "  service_description            idp-%s\n", $primaryScope;
    printf $nagConf "  contact_groups                 samlmd-cg-%s\n", $primaryScope;
    print  $nagConf "  use                            samlmd-generated-serviceescalation\n";
    print  $nagConf "}\n\n";

}

# Do we need to restart naemon
if (defined $c->{'restart'} and $c->{'nagiosRestartCommand'}) {
    if ($c->{'nagiosCheckCommand'}) {
        system($c->{'nagiosCheckCommand'}) == 0
            or die ('nagios configuration failed, bailing out of restart');
    }
    print STDERR "Restarting monitoring process\n" if defined $c->{'verbose'};
    system($c->{'nagiosRestartCommand'});
}

__END__

=head1 NAME

update-samlmd-idps.pl - create Nagios-style monitoring config from SAML metadata

=head1 SYNOPSIS

update-samlmd-idps.pl [-c C<config>] [--restart] [options...]

=head1 OPTIONS

=over 8

=item B<--config>=C<file>, -c C<file>

Specify the location of a YAML config file. Defaults to C<$OMD_ROOT/etc/samlmd-idps.cfg>, and failing that looks for C<samlmd-idps.cfg> in the current directory.

=item B<--verbose>, -v

Produce verbose output to STDERR

=item B<--force>, -f

Force writing a new Nagios config even if freshness tests say it is not necessary.

=item B<--restart>, --reload, -r

Restart/reload the monitoring system (requires that B<nagiosRestartCommand> is set in the config file).

=item B<--nagiosConfigDir>=C<dir>, -C C<dir>

Set the location of the Nagios config directory. Defaults to C<$OMD_ROOT/etc/nagios/conf.d>.

=item B<--nagiosConfigFile>=C<file>, -F C<file>

Set the location of the generated config file, relative to B<nagiosConfigDir>. Defaults to C<samlmd-generated-idps.cfg>.

=item B<--metadataURL>=C<url>, -U C<url>

Set the URL to fetch metadata from. Must me a method supported by L<LWP::UserAgent>.

=item B<--birkURL>=C<url>, -B C<url>, B<--birkURN>=C<url>

Set the base URL (or URN prefix) for the BIRK IdP Proxy (WAYF/SAFIRE). Note that you must set a URL if you want to use a URN.

=item B<--tokenKey>=C<string>, -k C<string>

Set an encryption key that is used to generate an opaque opt-out "unsubscribe" token for each contact defination. Defaults to C<changeme>.

=item B<--write>=C<file>, -w C<file>

Writes a new config file to C<file> (can be used to bootstrap a config file).

=item B<--dump>, -D

Dump the config with Data::Dumper for debugging.

=item B<--help>, -h, -?

Display usage information.

=back

=head1 CONFIG FILE

B<update-samlmd-idps.pl> expects a YAML config file. All of the L<OPTIONS> above can also be expressed in the config file -- the primary option should be used as the YAML key. The following additional options exist:

=over 8

=item B<disableContacts>

A list of email addresses that should never receive notifications.

=back

=head2 SAMPLE CONFIG

 # This is the configuration for update-samlmd-idps.pl
 ---
 nagiosConfigDir: /omd/sites/mysite/etc/nagios/conf.d
 nagiosConfigFile: samlmd-generated-idps.cfg
 nagiosCheckCommand: naemon -v /omd/sites/mysite/tmp/naemon/naemon.cfg
 nagiosRestartCommand: omd restart naemon
 metadataURL: https://metadata.example.ac.za/

 disableContacts:
  - user@example.ac.za

=head1 LICENSE

This software is released under an MIT license.
